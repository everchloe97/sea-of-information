---
title: 트랜잭션

date: 2022-08-05
---

## 면접 질문

데이터베이스 트랜잭션이란 무엇인가요?
<br />

## 답변

-   데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위를 말합니다
-   데이터베이스에 접근하는 방법은 쿼리이인데, 트랜잭션은 이 쿼리들이 하나로 묶인 단위를 말합니다
-   트랜잭션은 다음과 같은 특징이 있습니다
    -   트랜잭션이 모두 반영되거나 혹은 전혀 반영되지 않아야 된다는 **원자성**
    -   트랜잭션의 작업 처리 결과는 항상 **일관성**이 있어야 한다
    -   둘 이상의 트랜잭션이 동시에 병행되어 실행되고 있을 때 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다는 **독립성**
    -   트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영되어야 한다는 **지속성**
-   트랜잭션에는 커밋과 롤백이라는 개념이 있습니다
    -   커밋이란 하나의 트랜잭션이 성공적으로 끝났고 DB가 일관성 있는 상태라는 것을 알려주는 연산입니다
    -   롤백이란 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 특징 중 **원자성**이 깨진 경우를 말합니다
        -   이때 트랜잭션이 시작되기 전의 상태로 되돌린다는 의미로 쓰입니다

# 꼬리 질문 1

그럼 트랜잭션의 격리 수준에는 어떤 것들이 있나요?

# 꼬리 질문 답변 1

-   격리 수준에는 낮은 수준부터 Read-Uncommitted, Read-Committed, Repeatable Read, Serializable이 있습니다.
    -   Read-Uncommitted
        -   커밋되지않거나 처리중인 데이터를 다른 트랜젝션에서 읽는 것을 허용하는 격리 수준입니다
    -   Read-Committed
        -   이를 허용하지 않습니다
        -   다른 트랜젝션이 정보를 조회할수 없으며 대기하게 됩니다.
        -   단 기존의 A 트렌젝션에서 수정한 행을 다른 B트랜젝션이 수정할 수는 있습니다.
        -   따라서 트렌젝션 A가 해당 행을 읽을 때 변경된 정보를 불러올수도 있습니다
    -   Repeatable-Read
        -   트랜잭션이 완료될때까지 SELECT 문장이 사용되는 모든 데이터에 LOCK을 걸어두는 격리 수준입니다.
        -   트렌젝션 내에서의 조회 데이터가 항상 동일함을 보장합니다.
        -   다른 사용자는 이 영역에 해당되는 데이터를 수정 불가능합니다.
        -   행 추가를 막지는 않습니다
    -   Serializable
        -   모든 조회데이터가 동일함을 보장합니다
        -   여러 트렌젝션이 동시에 같은 행에 접근할수 없습니다.이후 트렌젝션이 일어난다면 기다려야 합니다
        -   다른 사용자는 이 영역에 해당하는 데이터에 대해 수정 및 입력이 모두 차단됩니다
        -   교착 상태가 일어날 확률이 높고 성능을 떨어트리는 원인이 될 수 있습니다

# 꼬리 질문 2

격리 수준에 따라 발생하는 현상은 무엇이 있나요?

# 꼬리 질문 답변 2

-   팬텀 리드, 논-리피터블 리드, 더티 리드가 있습니다
    -   팬텀 리드
        -   한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상입니다
        -   트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상을 말합니다
    -   논 리피터블 리드
        -   같은 행에 두번 이상의 조회가 발생했는데, 그 값이 다른 경우입니다
        -   예를 들어, 10이던 포인트가 트랜젝션이 진행되는 중에 다른 기능을 통해 5포인트가 추가된다면 한 트랜젝션 내에서 포인트는 10과 15 두가지로 나타나게 됩니다
        -   이렇게 상이하게 나타나며 일관성이 깨진 현상을 말합니다
    -   더티 리드
        -   커밋되지 않은 수정 중인 데이터를 다른 트랜젝션에서 읽을 수 있도록 허용할 때 발생하는 현상입니다
        -   아직 커밋되지 않은 변경사항을 다른 트랜젝션이 볼수 있는 경우 발생합니다

## 꼬리 질문 3

어떤 것들을 고려해 이 격리수준을 조정해야 할까요

## 꼬리 질문 답변 3

-   Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있습니다
-   동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됩니다
-   레벨을 높게 조정할 수록 발생하는 비용이 증가하기도 합니다
-   따라서 서비스가 빠른 속도가 필요하며 동시성이 보장되어야한다면 낮은 격리 수준을, 데이터의 완전한 무결성을 보장해야 한다면 높은 격리 수준을 선택해야 할 것입니다

## 꼬리 질문 4

트렌젝션을 적용해본 경험이 있나요?

## 꼬리 질문 답변 4

-   팀프로젝트를 할 때, 결제를 통해 유저의 포인트 정보를 변경할때 Serializable 격리 수준을 적용해본 적이 있습니다.
-   결제 api가 저장되는 타이밍에 따라 포인트가 추가되지 않거나 다르게 저장되는 것을 방지하기 위해 가장 엄격한 격리수준을 적용했습니다
-   또한 유저의 포인트를 불러와야 하기에 유저정보를 조회할 때 비관적 락(pessimistic_write)을 걸어 다른 트랜잭션에서 읽지도 쓰지도 못하게 잠금을 걸어놓았던 기억이 있습니다
-   또 좋아요 기능에도 다소 높은 격리 수준인 repeatable-read를 적용했었는데, 사실 이 격리 수준이 적절한지는 모르겠지만, 순간적이거나 반복적인 변경에 같은 쿼리라도 값이 다를 수 있다는 생각이 들어 트랜젝션 내에서 값이 변경되는 것을 방지하기 위해 적용했던 기억이 있습니다
-   bossraid 프로젝트에서는 게임 레코드 생성에 serializable로 격리 수준을 설정했었는데, 중요한 테이블에 대한 create에는 엄격한 격리 수준을 걸어주는 것이 좋겠다는 판단 하에 적용했었습니다
